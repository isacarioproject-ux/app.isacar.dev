[
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "4c63ec47-b272-4351-ba0f-b58583e5a9e4",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC001-User Authentication with Email and Password",
    "description": "Verify that users can register, login, and reset password using email and password with password policies enforced.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Sign Up' button to navigate to registration page.\n        frame = context.pages[-1]\n        # Click on 'Sign Up' button to go to registration page\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Sign Up' button at index 13 to navigate to registration page.\n        frame = context.pages[-1]\n        # Click 'Sign Up' button at bottom to navigate to registration page\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[4]/p/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill the registration form with full name, email, password, confirm password, check the terms agreement checkbox, and submit the form.\n        frame = context.pages[-1]\n        # Input full name\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Input confirm password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click checkbox to agree to terms\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Sign Up button to submit registration form\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Sign In' button to login with registered email and password.\n        frame = context.pages[-1]\n        # Input registered email for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input registered password for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click 'Sign In' button to login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Logout from the dashboard to verify logout functionality.\n        frame = context.pages[-1]\n        # Click 'Sign In' button to open user menu or logout option if available\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on user menu button to find and click logout option.\n        frame = context.pages[-1]\n        # Click user menu button to open logout option\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[3]/div/ul/li/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Forgot password?' button to initiate password reset process.\n        frame = context.pages[-1]\n        # Click 'Forgot password?' button to start password reset\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input registered email and click 'Send reset email' button to request password reset.\n        frame = context.pages[-1]\n        # Input registered email for password reset\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send reset email' button to request password reset email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate following the reset link and enter a new compliant password to verify password reset success.\n        frame = context.pages[-1]\n        # Click 'Forgot password?' button to navigate to reset password form again\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input registered email for password reset again\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send reset email' button again to retry password reset request\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Back to login' button to return to login page.\n        frame = context.pages[-1]\n        # Click 'Back to login' button to return to login page\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry inputting registered email and password into login form and click 'Sign In' button.\n        frame = context.pages[-1]\n        # Retry input registered email for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Retry input old password for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click 'Sign In' button to login with old password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Registration Complete! Welcome User').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: User registration, login, and password reset with enforced password policies did not complete successfully.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136840243265//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.927Z",
    "modified": "2025-11-26T06:00:40.385Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "f3a8169e-ff07-4cc3-8390-e7cce609724e",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC002-User Authentication with Google OAuth",
    "description": "Validate login, account linking, and session management via Google OAuth integration.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Continuar com Google' button to initiate Google OAuth login\n        frame = context.pages[-1]\n        # Click 'Continuar com Google' button to start Google OAuth login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input the Google account email and click Next to proceed with authentication\n        frame = context.pages[-1]\n        # Input Google account email\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[2]/div/div/div/form/span/section/div/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed with Google account login\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify the error message is displayed and then return to the app login page to test logout and invalid/canceled consent scenarios.\n        frame = context.pages[-1]\n        # Click 'Try again' link to retry or return to login page\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input the Google account email again and click Next to proceed with authentication\n        frame = context.pages[-1]\n        # Input Google account email\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[2]/div/div/div/form/span/section/div/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed with Google account login\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Try again' link to return to the app login page and continue testing logout and invalid/canceled consent scenarios.\n        frame = context.pages[-1]\n        # Click 'Try again' link to retry or return to login page\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test logout functionality by returning to the app login page or simulate invalid/canceled consent scenario if possible.\n        await page.goto('http://localhost:3005/auth', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Test logout functionality by clicking on logout if logged in, or proceed to test invalid/canceled consent scenario by clicking 'Continuar com Google' button\n        frame = context.pages[-1]\n        # Click 'Continuar com Google' button to test invalid or canceled consent scenario\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input the Google account email 'kleovekleh@gmail.com' and click Next to proceed with authentication.\n        frame = context.pages[-1]\n        # Input Google account email\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[2]/div/div/div/form/span/section/div/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed with Google account login\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Try again' link to return to the app login page and continue testing logout and invalid/canceled consent scenarios.\n        frame = context.pages[-1]\n        # Click 'Try again' link to retry or return to login page\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input the Google account email 'kleovekleh@gmail.com' and click Next to proceed with authentication.\n        frame = context.pages[-1]\n        # Input Google account email\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[2]/div/div/div/form/span/section/div/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed with Google account login\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/c-wiz/main/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome back!').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: User login, account linking, or session management via Google OAuth did not succeed as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136853562119//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.934Z",
    "modified": "2025-11-26T06:00:53.736Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "6f944971-df8e-4cfd-9ffd-60bca1d8c22f",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC003-Onboarding Flow Completion and Data Persistence",
    "description": "Test that new users can complete onboarding flow steps and data persists across sessions; skipping optional steps does not block progress.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Sign Up button to start new user registration and onboarding\n        frame = context.pages[-1]\n        # Click Sign Up button to start new user registration\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Sign Up button to switch to sign up form for new user registration\n        frame = context.pages[-1]\n        # Click Sign Up button to switch to sign up form\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in Full name, Email, Password, Confirm password, check agreement checkbox, then click Sign Up button to submit registration\n        frame = context.pages[-1]\n        # Input Full name\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Kleo Vekleh')\n        \n\n        frame = context.pages[-1]\n        # Input Email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input Password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Input Confirm password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Check agreement checkbox\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Sign Up button to submit registration\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password to sign in and start onboarding\n        frame = context.pages[-1]\n        # Input Email to sign in\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input Password to sign in\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in and start onboarding\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password to sign in again and verify onboarding state restoration\n        frame = context.pages[-1]\n        # Input Email to sign in\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input Password to sign in\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in and verify onboarding state restoration\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Sign Up' button to verify if the user can re-register or check for account confirmation instructions\n        frame = context.pages[-1]\n        # Click Sign Up button to check registration or confirmation status\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Forgot password?' button to initiate password reset process\n        frame = context.pages[-1]\n        # Click 'Forgot password?' button to start password reset\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Send reset email' button to initiate password reset process\n        frame = context.pages[-1]\n        # Click 'Send reset email' button to send password reset instructions\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Onboarding Complete! Welcome to your new workspace').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: New users cannot complete onboarding flow steps or data does not persist across sessions; skipping optional steps may be blocking progress.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136808378608//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.941Z",
    "modified": "2025-11-26T06:00:08.536Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "d6dbf743-7ded-4f0b-9b8d-0b2859691c55",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC004-Task Creation and Management with Subtasks and Comments",
    "description": "Verify creating tasks with priorities, subtasks, comments, time tracking, and block editor formatting works correctly and reflects in UI.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In button to log in\n        frame = context.pages[-1]\n        # Input email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry login by inputting email and password again and clicking Sign In\n        frame = context.pages[-1]\n        # Input email again\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password again\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button again\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'My work' in the sidebar to navigate to the Tasks module\n        frame = context.pages[-1]\n        # Click on 'My work' to navigate to Tasks module\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[2]/div/ul/div[2]/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try refreshing the page to resolve loading issue or check for any clickable elements to retry navigation to Tasks module\n        await page.goto('http://localhost:3005/meu-trabalho', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to reload the page or navigate back to dashboard or main page to recover from onboarding loading state\n        await page.goto('http://localhost:3005/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password, then click Sign In button to log in again\n        frame = context.pages[-1]\n        # Input email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Task creation with priority High and subtasks completed successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: Creating tasks with priorities, subtasks, comments, time tracking, and block editor formatting did not work correctly or did not reflect in the UI.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136759163329//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.948Z",
    "modified": "2025-11-26T05:59:19.298Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "90dce740-9018-4665-a1ec-f3849a90ebde",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC005-Financial Management: Transactions, Budgets, and Reports",
    "description": "Ensure users can add, edit, and delete transactions, create and customize budgets, categorize expenses, and generate interactive charts and reports.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In button to log in\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Transaction Successfully Added').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution has failed because the expected transaction confirmation message 'Transaction Successfully Added' was not found on the page. This indicates that adding, editing, or deleting transactions, or other financial operations did not complete successfully.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136537828501//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.954Z",
    "modified": "2025-11-26T05:55:37.941Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "483db132-7835-4df3-935d-44e61eed254f",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC006-Project Management with Kanban Boards and Team Collaboration",
    "description": "Verify users can create projects, manage tasks on Kanban boards, drag and drop tasks between customizable status columns, and upload documents.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In button to log in.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'My Projects' to navigate to the Projects module.\n        frame = context.pages[-1]\n        # Click on 'My Projects' in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[2]/div/ul/div[3]/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click to create a new project.\n        frame = context.pages[-1]\n        # Click on existing project 'Ola' to check if it allows editing or creating new projects\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div[2]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to find a 'Create New Project' button or similar option or look for alternative ways to create a new project.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Click on the existing project 'Ola' to check if it allows editing or adding new projects or status columns.\n        frame = context.pages[-1]\n        # Click on existing project 'Ola' to explore project details and options\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div[2]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the '+ Novo' button (index 35) to create a new project.\n        frame = context.pages[-1]\n        # Click '+ Novo' button to create a new project\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div/div[2]/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password, then click Sign In button to log in again.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if there is an option to reset password or sign up for a new account, or retry login with corrected credentials.\n        frame = context.pages[-1]\n        # Click 'Forgot password?' to initiate password reset process\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send reset email to recover password or go back to login to retry.\n        frame = context.pages[-1]\n        # Click 'Send reset email' button to initiate password reset process\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry clicking the 'Sign In' button (index 11) to attempt login again.\n        frame = context.pages[-1]\n        # Retry clicking the 'Sign In' button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password, then click Sign In to log in.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Project Creation Successful').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to verify project creation, task management on Kanban boards, drag and drop functionality, document upload, and collaboration features as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136807466887//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.961Z",
    "modified": "2025-11-26T06:00:07.638Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "b61dc6ef-343f-43b7-a004-b779e708c15a",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC007-Workspace Management with Role-Based Permissions and Invitations",
    "description": "Test workspace creation, switching, member invitations with expirations, and role assignment enforcing access controls properly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In to authenticate.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down or explore the page to find the workspace creation button or menu.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Click on 'My work' link to explore workspace creation options.\n        frame = context.pages[-1]\n        # Click on 'My work' link to find workspace creation options\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[2]/div/ul/div[2]/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking on the user profile button (index 20) to explore workspace or account settings for workspace creation options.\n        frame = context.pages[-1]\n        # Click user profile button to explore workspace or account settings\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[3]/div/ul/li/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Look for workspace creation or management option in the user profile menu or elsewhere on the page.\n        await page.mouse.wheel(0, 200)\n        \n\n        # -> Try to reload the onboarding page to recover from the loading state or navigate back to the dashboard to attempt workspace creation from there.\n        await page.goto('http://localhost:3005/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password, then click Sign In to authenticate again.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Clear email and password fields, re-input credentials carefully, and click Sign In again to retry authentication.\n        frame = context.pages[-1]\n        # Clear email field\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Clear password field\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Re-input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Re-input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to retry login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password carefully and click Sign In to authenticate again.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Workspace Creation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Workspace creation, member invitations, role assignments, and access control enforcement did not complete successfully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/176413689466142//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.968Z",
    "modified": "2025-11-26T06:01:34.831Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "df8a591d-d0b9-4a0e-8b9e-fce1f6ae225b",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC008-Multi-language Support and Persistence",
    "description": "Ensure switching languages updates UI immediately and selected language persists across sessions and pages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the language selector button to open language options and switch to Portuguese.\n        frame = context.pages[-1]\n        # Click the language selector button showing 'EN' to open language options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to a different module/page to verify language persistence.\n        frame = context.pages[-1]\n        # Click 'Iniciar sesin' button to log in or proceed to next module\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking 'Registrarse' button to navigate to registration page and check if language remains Spanish.\n        frame = context.pages[-1]\n        # Click 'Registrarse' button to navigate to registration page and verify language persistence\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try inputting email into the correct input field index 5 and password into index 6, then click 'Iniciar sesin' button to login.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click 'Iniciar sesin' button to login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to a different module or page within the dashboard to verify language remains Spanish.\n        frame = context.pages[-1]\n        # Click toggle theme button to check if language remains Spanish on UI change\n        elem = frame.locator('xpath=html/body/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Click on a different module link such as 'My work' (index 7) to verify language remains Spanish across modules.\n        frame = context.pages[-1]\n        # Click 'My work' module link to verify language persistence\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[2]/div/ul/div[2]/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Language switch successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Language switching did not update UI immediately or persist across sessions as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136677638627//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.974Z",
    "modified": "2025-11-26T05:57:57.769Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "03b2dc9f-3017-4a20-abc5-4b9c496c4e90",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC009-Dashboard Functionality: Draggable and Customizable Cards",
    "description": "Verify dashboard loads with multiple cards showing tasks, projects, and financial summaries; cards can be dragged and customized with real-time data updates.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In button to login and navigate to main Dashboard.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard loaded with all cards successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Dashboard did not load with multiple cards showing tasks, projects, and financial summaries as expected. The cards could not be verified for drag, customization, or real-time data updates.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136530162464//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.981Z",
    "modified": "2025-11-26T05:55:30.286Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "d6c68e93-9b7c-44d5-9368-669beab210fe",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC010-PWA Features: Offline Mode, Installation, and Push Notifications",
    "description": "Test offline capabilities with local caching and syncing, PWA installation prompts, and receiving push notifications.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In button to log in.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Install App' button to enable PWA install prompt and install the app.\n        frame = context.pages[-1]\n        # Click 'Install App' button to enable PWA install prompt and install the app\n        elem = frame.locator('xpath=html/body/div/div/div/main/header/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode by disabling network connection.\n        frame = context.pages[-1]\n        # Select 'Mobile' option to install the app as PWA on mobile device\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Perform data entry actions to test local caching and offline UI feedback.\n        frame = context.pages[-1]\n        # Click 'My Projects' to open projects section for data entry actions\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[2]/div/ul/div[3]/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create a new project or edit an existing project to test offline data caching and UI feedback.\n        frame = context.pages[-1]\n        # Click on the project card 'Ola' to open project details for editing or adding tasks\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div[2]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create a new project by clicking the 'Novo' button to test offline data caching and UI feedback.\n        frame = context.pages[-1]\n        # Click 'Novo' button to create a new project while offline\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div/div[2]/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Reload or navigate back to the projects page to regain access to project creation UI.\n        await page.goto('http://localhost:3005/meus-projetos', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password, then click Sign In button to log in.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify or reset login credentials to successfully log in and continue testing.\n        frame = context.pages[-1]\n        # Click 'Forgot password?' to initiate password reset or recovery process\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send password reset email to recover or verify login credentials.\n        frame = context.pages[-1]\n        # Click 'Send reset email' button to initiate password reset process\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Offline Mode Enabled - Data Cached Locally').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Offline capabilities test did not pass. The app did not show expected offline status or local caching UI feedback as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136777989767//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.988Z",
    "modified": "2025-11-26T05:59:38.208Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "95986e99-8524-4134-bf35-53431bff8b00",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC011-Google Workspace Integration: Gmail Invoice Scanning, Calendar Sync, and Sheets Export",
    "description": "Validate authorization flows for Google services and functionality of invoice scanning, calendar synchronization, and export to Sheets features.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then sign in to proceed with Google OAuth authorization.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Integrations link to open Integrations settings.\n        frame = context.pages[-1]\n        # Click on Integrations link to open Integrations settings\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[2]/div/ul/div[6]/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Look for and click the button or link to initiate Google OAuth authorization for Gmail, Calendar, and Sheets.\n        frame = context.pages[-1]\n        # Click toggle or button to initiate Google OAuth authorization for Gmail, Calendar, and Sheets scopes\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Scan Gmail' button to initiate invoice scanning from Gmail.\n        frame = context.pages[-1]\n        # Click 'Scan Gmail' button to start invoice scanning from Gmail\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div[2]/div/div/div[2]/div[2]/div[3]/div[2]/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Authorization Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Authorization flows for Google services and functionality of invoice scanning, calendar synchronization, and export to Sheets features did not complete successfully.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136719995672//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:12.994Z",
    "modified": "2025-11-26T05:58:40.153Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "23846203-98da-4179-b89f-a4db29ea79b9",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC012-Security: Password Policies, Row-Level Security, and Data Encryption",
    "description": "Ensure strong password policies are enforced, row-level security restricts data access by user/role, and sensitive data is encrypted in transit and storage.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Sign Up to attempt registration with weak or common passwords.\n        frame = context.pages[-1]\n        # Click on Sign Up button to go to registration page\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Sign Up button to navigate to registration form.\n        frame = context.pages[-1]\n        # Click on Sign Up button to go to registration form\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to register with a weak password and verify registration is blocked with validation messages.\n        frame = context.pages[-1]\n        # Input full name\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input weak password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Input confirm password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Check agreement checkbox\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Sign Up to submit registration with weak password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Login with valid user credentials and attempt to access data from other users or workspaces to verify row-level security.\n        frame = context.pages[-1]\n        # Input valid email for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login with valid user\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Unbreakable Password Achieved!').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Registration with weak or common passwords was not blocked, row-level security or encryption policies might not be enforced as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136677537341//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:13.000Z",
    "modified": "2025-11-26T05:57:57.669Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "3e79c077-f24a-4323-83cb-eab0428e2432",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC013-Global Search Functionality with Keyboard Shortcuts and Categorized Results",
    "description": "Verify global search returns categorized results quickly and keyboard shortcuts open search interface and navigate results.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In button to log in.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the search input box (index 22) to focus it, then try to input the search term 'test' again.\n        frame = context.pages[-1]\n        # Click on the search input box to focus it\n        elem = frame.locator('xpath=html/body/div/div/div/main/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Buscar...' button (index 22) to open the global search interface explicitly.\n        frame = context.pages[-1]\n        # Click the 'Buscar...' button to open global search interface\n        elem = frame.locator('xpath=html/body/div/div/div/main/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password, then click Sign In button to log in again.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Clear the email and password fields, re-input the provided credentials, and click Sign In button to attempt login again.\n        frame = context.pages[-1]\n        # Clear email input field\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Clear password input field\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Sign In button to attempt login with provided credentials.\n        frame = context.pages[-1]\n        # Click Sign In button to attempt login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Search Results Categorized by Type').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Global search did not return categorized results quickly, or keyboard shortcuts did not open the search interface and navigate results as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136804053674//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:13.011Z",
    "modified": "2025-11-26T06:00:04.263Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "5477fd7d-dd4d-4b2b-b62c-c1dc783cb5d1",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC014-Responsive UI Across Various Screen Sizes",
    "description": "Test the web app layout and usability on mobile phones, tablets, and large monitors ensuring all components are accessible and functional.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In to access the app on mobile screen size.\n        frame = context.pages[-1]\n        # Input the email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input the password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click the Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the sidebar toggle button to verify it collapses and expands the sidebar correctly on mobile.\n        frame = context.pages[-1]\n        # Click the sidebar toggle button to collapse/expand sidebar on mobile\n        elem = frame.locator('xpath=html/body/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'My Projects' navigation link to verify it loads correctly and content is accessible on mobile screen size.\n        frame = context.pages[-1]\n        # Click 'My Projects' navigation link on mobile screen size\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[2]/div/ul/div[3]/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the email input field to focus it before inputting text, then input email and password, and click Sign In to login again.\n        frame = context.pages[-1]\n        # Click the email input field to focus it\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input the email address after focusing the field\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input the password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click the Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Resize the viewport to tablet screen size and verify the login page layout and usability.\n        await page.goto('http://localhost:3005/auth', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Resize the viewport to desktop screen size and verify the login page layout and usability.\n        await page.goto('http://localhost:3005/auth', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Sign in to your account').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign In').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign Up').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Remember me').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Forgot password?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Continue with Google').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Don\\'t have an account? Sign Up').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Toggle theme').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136833359441//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:13.018Z",
    "modified": "2025-11-26T06:00:33.507Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "b156a7c6-91fe-4b0e-8290-1da95fe58424",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC015-User Settings: Profile Update, Notification Preferences, and Billing Management",
    "description": "Verify users can update profile details, change notification settings including push preferences, manage billing plans and connected integrations.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In to authenticate.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on User menu to find Settings or Profile options.\n        frame = context.pages[-1]\n        # Click User menu button to open user settings options\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[3]/div/ul/li/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Profile menu item to navigate to Profile settings.\n        frame = context.pages[-1]\n        # Click on Profile menu item to open Profile settings\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to clear and input new full name text in the full name field (index 25) again or skip to password fields.\n        frame = context.pages[-1]\n        # Click on full name input field to focus\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[3]/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input new full name text into the full name field (index 26), then input new password and confirm password, and save changes.\n        frame = context.pages[-1]\n        # Input new full name text\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[3]/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Kleove Yaguaracuto Updated')\n        \n\n        frame = context.pages[-1]\n        # Input new password\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[3]/div[2]/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('NewPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Confirm new password\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[3]/div[2]/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('NewPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click 'Salvar alteraes' button to save profile changes\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Reload the profile page to verify that the updated profile details persist.\n        await page.goto('http://localhost:3005/settings/profile', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on User menu to open and then click on Notifications to access notification settings.\n        frame = context.pages[-1]\n        # Click User menu button to open user settings options\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[3]/div/ul/li/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Notifications menu item to open Notifications settings.\n        frame = context.pages[-1]\n        # Click on Notifications menu item to open Notifications settings\n        elem = frame.locator('xpath=html/body/div[2]/div/div[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to reveal notification preferences toggles and then toggle some preferences to test saving.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Toggle off 'New Projects' email notification (index 28) and toggle on 'Team' email notification (index 32) to test saving preferences, then click 'Salvar' button (index 26) to save.\n        frame = context.pages[-1]\n        # Toggle off 'New Projects' email notification\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to scroll down further to reveal notification toggles or refresh the page to reload elements.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.goto('http://localhost:3005/settings/notifications', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to Billing settings to continue testing billing plan management as notification toggles are not accessible.\n        frame = context.pages[-1]\n        # Click User menu button to open user settings options\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div[2]/div/div[3]/div/ul/li/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Toggle off 'New Projects' email notification (index 1) and toggle on 'Team' email notification (index 3) to test saving preferences, then click 'Salvar' button (index 0) to save.\n        frame = context.pages[-1]\n        # Toggle off 'New Projects' email notification\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[4]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Toggle on 'Team' email notification\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[2]/div/div[2]/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 'Salvar' button to save notification preferences\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Profile Update Successful').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to verify updating profile details, notification settings, billing plans, and connected integrations. The expected confirmation message 'Profile Update Successful' was not found on the page.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136963340591//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:13.025Z",
    "modified": "2025-11-26T06:02:43.531Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "e57f1e84-af61-4462-8a86-ae174cbdec37",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC016-Real-Time Data Syncing and Updates Across Modules",
    "description": "Confirm that changes in tasks, projects, finance, and budgets propagate instantly to all connected clients and UI reflects real-time updates.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password and click Sign In to log in first session.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Open a new tab for second session and navigate to login page.\n        await page.goto('http://localhost:3005/auth', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password and click Sign In to log in second session.\n        frame = context.pages[-1]\n        # Input email for login in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Open a new tab for second session and navigate to login page.\n        await page.goto('http://localhost:3005/auth', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password and click Sign In to log in second session.\n        frame = context.pages[-1]\n        # Input email for login in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to clear the email and password fields and re-enter credentials carefully, then click Sign In again to attempt login in second session.\n        frame = context.pages[-1]\n        # Clear email field in second session login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Clear password field in second session login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Re-enter email for login in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Re-enter password for login in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in second session\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to use a different browser or incognito mode for the second session to avoid session conflicts and attempt login again.\n        await page.goto('about:incognito', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        await page.goto('http://localhost:3005/auth', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password and click Sign In to log in second session in incognito mode.\n        frame = context.pages[-1]\n        # Input email for login in second session incognito\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login in second session incognito\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to log in second session incognito\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Real-time synchronization successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test plan failed: Changes in tasks, projects, finance, and budgets did not propagate instantly to all connected clients, and UI did not reflect real-time updates as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/1764136770680597//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:13.031Z",
    "modified": "2025-11-26T05:59:30.816Z"
  },
  {
    "projectId": "a1f6f5d6-e87b-4d4c-8af6-c531d9aadd99",
    "testId": "d48dede9-6dc7-4074-a61b-107a1d18fbd8",
    "userId": "c4f8d408-60b1-709d-5aaa-97dfa344d7ea",
    "title": "TC017-Error Handling: Invalid Inputs and Server Errors",
    "description": "Validate the app handles invalid user inputs and server errors gracefully with user-friendly messages and no data corruption.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter invalid inputs in the login form such as empty email, invalid email format, and empty password, then try to submit.\n        frame = context.pages[-1]\n        # Clear email input to test empty required field validation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Clear password input to test empty required field validation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        # -> Enter invalid email format and valid password, then try to submit the form to check validation error.\n        frame = context.pages[-1]\n        # Enter invalid email format to test validation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email-format')\n        \n\n        frame = context.pages[-1]\n        # Enter valid password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass123!')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit the form\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test form submission with valid email and empty password to check validation error.\n        frame = context.pages[-1]\n        # Enter valid email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Clear password to test empty password validation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit the form\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate server unavailability or timeout on login request to verify app displays appropriate error notifications without freezing or crashing.\n        frame = context.pages[-1]\n        # Enter valid password to prepare for server error simulation on login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass123!')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit the form and simulate server error\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt actions that require permissions without correct role to confirm access denied messages and no data leakage.\n        frame = context.pages[-1]\n        # Click Sign Up to navigate to registration or restricted area for permission testing\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try alternative ways to navigate to a page or perform an action that requires permissions without the correct role to confirm access denied messages and no data leakage.\n        frame = context.pages[-1]\n        # Click alternative 'Sign Up' link at bottom of the form to navigate for permission testing\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[4]/p/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter invalid inputs in the Sign Up form such as empty required fields, invalid email format, mismatched passwords, and unchecked terms agreement, then try to submit to check validation errors.\n        frame = context.pages[-1]\n        # Clear Full name to test empty required field validation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Enter invalid email format to test validation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email')\n        \n\n        frame = context.pages[-1]\n        # Enter valid password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Enter mismatched confirm password to test validation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password321!')\n        \n\n        frame = context.pages[-1]\n        # Click Sign Up button to submit the form with invalid inputs\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Sign Up button to navigate to the Sign Up form and continue testing invalid inputs and permission restrictions.\n        frame = context.pages[-1]\n        # Click Sign Up button to navigate to Sign Up form\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test validation errors for empty full name, mismatched passwords, and unchecked terms agreement by submitting the form with these invalid inputs.\n        frame = context.pages[-1]\n        # Leave full name empty to test required field validation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Enter valid email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Enter valid password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Enter mismatched confirm password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password321!')\n        \n\n        frame = context.pages[-1]\n        # Click Sign Up button to submit the form with empty full name, mismatched passwords, and unchecked terms agreement\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Sign Up' button to navigate to the Sign Up form to simulate server error on sign up and test permission restrictions.\n        frame = context.pages[-1]\n        # Click Sign Up button to navigate to Sign Up form\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill the Sign Up form with valid inputs and simulate server unavailability or timeout to verify app displays appropriate error notifications without freezing or crashing.\n        frame = context.pages[-1]\n        # Enter valid full name\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Enter valid email\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Enter valid password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Enter matching confirm password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Check the terms and conditions checkbox\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Sign Up button to submit the form and simulate server error\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Sign in to your account').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign In').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign Up').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Remember me').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Forgot password?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Continue with Google').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Don\\'t have an account? Sign Up').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4f8d408-60b1-709d-5aaa-97dfa344d7ea/176413686258236//tmp/test_task/result.webm",
    "created": "2025-11-26T05:53:13.038Z",
    "modified": "2025-11-26T06:01:02.780Z"
  }
]
